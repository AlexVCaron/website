---
import MarkdownTocLayout from '@layouts/MarkdownTocLayout.astro';
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import { sequence } from 'astro:middleware';
// 1. Generate a new path for every collection entry
export async function getStaticPaths() {
    const tools: CollectionEntry<'tools'>[] = await getCollection('tools');
    return tools.map((entry: CollectionEntry<'tools'>) => {
        const version = entry.id.split('/')[1];
        const versioned_tools = tools.filter((tool) => tool.id.split('/')[1] === version);
        const section_names = [...new Set(versioned_tools.map((entry) => entry.id.split('/')[2]))];
        const sections = section_names
            .filter((entry) => entry !== 'index.md')
            .map((entry) => {
                return {
                    section_name: entry,
                    section_slug:
                        '/tools/' +
                        versioned_tools
                            .find(
                                (tool_entry) =>
                                    tool_entry.id.endsWith('index.md') && tool_entry.id.split('/')[2] === entry,
                            )
                            ?.id.replace(/index\.md$/, 'index'),
                    children: versioned_tools
                        .filter((child) => child.id.split('/')[2] === entry && child.id.split('/')[3])
                        .filter((child) => child.id.split('/')[3] !== 'index.md')
                        .map((tool_entry) => {
                            return {
                                title: `${tool_entry.id.split('/')[3].replace(/\.md$/, '')}`,
                                slug: '/tools/' + tool_entry.id.replace(/\.md$/, ''),
                            };
                        }),
                };
            });
        // reshuffle sections with section name pipeline_lint_tests first, then modules_lint_tests, then subworkflows_lint_tests and then api
        sections.sort((a, b) => {
            if (a.section_name === 'pipeline_lint_tests') {
                return -1;
            }
            if (b.section_name === 'pipeline_lint_tests') {
                return 1;
            }
            if (a.section_name === 'api') {
                return -1;
            }
            if (b.section_name === 'api') {
                return -1;
            }
            return 0;
        });

        return {
            params: { version: version, slug: entry.id.replace(`docs/${version}/`, '').replace(/\.md$/, '') },
            props: { entry: entry, sections: sections },
        };
    });
}
// 2. For your template, you can get the entry directly from the prop
const { entry, sections } = Astro.props;

let { headings, Content } = await entry.render();
const title = 'nf-core/tools API documentation';
const subtitle = 'Automated documentation for nf-core/tools methods, classes and linting rules.';
const md_github_url = 'https://github.com/nf-core/website/blob/main/src/content/tools/' + entry.id;

const module_name = headings[0].text;
headings.map((heading) => {
    // remove everything inside paranthesis
    heading.text = heading.text.replace(/\(.*\)/, '()');
    // remove module name from headings
    heading.text = heading.text.replace(module_name + '.', '');
    // remove class in the beginning of the heading
    heading.text = heading.text.replace(/^class/, '');
    // add word-break hints after before periods
    heading.text = heading.text.replaceAll(/\./g, '.\u200B');
});
---

<MarkdownTocLayout
    title={title}
    subtitle={subtitle}
    md_github_url={md_github_url}
    headings={headings}
    viewTransitions={true}
    leftSidebar={true}
    sections={sections}
    viewTransitions={true}
    doubleNavbar={false}
>
    <Content />
</MarkdownTocLayout>
<style lang="scss">
    @import 'src/styles/_variables.scss';
    h3 {
        white-space: nowrap;
    }
</style>
