---
import MarkdownTocLayout from '@layouts/MarkdownTocLayout.astro';
import FooterPrevNext from '@components/footer/FooterPrevNext.astro';
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import type { SidebarEntry } from '@utils/types';

export async function getStaticPaths() {
    const docs = await getCollection('docs');
    return docs.map((doc) => ({
        params: {
            doc: doc.slug,
        },
        props: {
            doc: doc,
        },
    }));
}
const title = Astro.props.doc.data.title;
const subtitle = Astro.props.doc.data.subtitle;
const { headings, Content, remarkPluginFrontmatter } = await Astro.props.doc.render();

let prev_page: CollectionEntry<'docs'> | null = null;
let next_page: CollectionEntry<'docs'> | null = null;

const docs = await getCollection('docs');
let sections: SidebarEntry[] = [
    { type: 'group', label: 'Tutorials', href: '/docs/tutorials', entries: [], collapsed: true },
    { type: 'group', label: 'Usage', href: '/docs/usage', entries: [], collapsed: true },
    { type: 'group', label: 'Checklists', href: '/docs/checklists', entries: [], collapsed: true },
    { type: 'group', label: 'Guidelines', href: '/docs/guidelines', entries: [], collapsed: true },
];

// sort docs first depth, then by weight, then by title
const sortDocs = (a: CollectionEntry<'docs'>, b: CollectionEntry<'docs'>) => {
    if (a.slug.split('/').length < b.slug.split('/').length) {
        return -1;
    } else if (a.slug.split('/').length > b.slug.split('/').length) {
        return 1;
    } else {
        if (a.data.weight && !b.data.weight) {
            return -1;
        } else if (!a.data.weight && b.data.weight) {
            return 1;
        } else if (a.data.weight && b.data.weight) {
            if (a.data.weight < b.data.weight) {
                return -1;
            } else if (a.data.weight > b.data.weight) {
                return 1;
            }
        } else {
            if (a.data.title < b.data.title) {
                return -1;
            } else if (a.data.title > b.data.title) {
                return 1;
            } else {
                return 0;
            }
        }
    }
};
let usageDocs: CollectionEntry<'docs'>[] = [];
let tutorialDocs: CollectionEntry<'docs'>[] = [];
let checklistDocs: CollectionEntry<'docs'>[] = [];
let guidelineDocs: CollectionEntry<'docs'>[] = [];
docs.map((doc) => {
    if (doc.slug.startsWith('tutorials/')) {
        tutorialDocs.push(doc);
    }
    if (doc.slug.startsWith('usage/')) {
        usageDocs.push(doc);
    }
    if (doc.slug.startsWith('checklists/')) {
        checklistDocs.push(doc);
    }
    if (doc.slug.startsWith('guidelines/')) {
        guidelineDocs.push(doc);
    }
});
tutorialDocs.sort(sortDocs);
usageDocs.sort(sortDocs);
checklistDocs.sort(sortDocs);
guidelineDocs.sort(sortDocs);
// add entries to sections
tutorialDocs.forEach((doc) => {
    // get sections for tutorials
    let index = sections.findIndex((section) => section.label === 'Tutorials');

    sections[index].type === 'group' &&
        sections[index].entries.push({
            type: 'link',
            label: doc.data.title,
            href: '/docs/' + doc.slug,
            isCurrent: Astro.url.pathname === '/docs/' + doc.slug,
        });
});

// find the index of the current page and use that to get the previous and next page
const url = Astro.url.pathname.replace(/\/$/, '').replace(/\.html$/, '');
const currentDocs = (() => {
    if (url.startsWith('/docs/tutorials')) {
        return tutorialDocs;
    } else if (url.startsWith('/docs/usage')) {
        return usageDocs;
    } else if (url.startsWith('/docs/checklists')) {
        return checklistDocs;
    } else if (url.startsWith('/docs/guidelines')) {
        return guidelineDocs;
    }
})();

if (!currentDocs) {
    console.error('Could not find current page ' + Astro.url.pathname + ' in docs collection');
} else {
    const current_page_index = currentDocs.findIndex((page) => '/docs/' + page.slug === url);

    if (current_page_index === -1) {
        console.error('Could not find current page ' + Astro.url.pathname + ' in docs collection');
    } else {
        prev_page = currentDocs[current_page_index - 1];
        prev_page =
            prev_page && prev_page.slug?.split('/').slice(-2)[0] === url.split('/').slice(-2)[0] ? prev_page : null;
        next_page = currentDocs[current_page_index + 1];
        next_page =
            next_page && next_page.slug?.split('/').slice(-2)[0] === url.split('/').slice(-2)[0] ? next_page : null;
    }
}
const md_github_url = 'https://github.com/nf-core/website/blob/main/src/content/docs/' + Astro.props.doc.id;
// remove leading and trailing slash
const splitUrl = `${url}/`.replace(/^\/|\/$/g, '').split('/');
---

<MarkdownTocLayout
    title={title}
    subtitle={subtitle}
    meta_title={'Docs: ' + title}
    md_github_url={md_github_url}
    headings={headings}
    leftSidebar={true}
    sections={sections}
    viewTransitions={true}
    docSearchTags={[
        { name: 'page_type', content: 'Docs' },
        { name: 'page_rank', content: '8' },
        { name: 'page_subtype', content: currentDocs === usageDocs ? 'Usage' : 'Contributing' },
    ]}
>
    <div slot="header-top" class="d-none d-md-block">
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                {
                    splitUrl.slice(0, -1).map((slug, i) => (
                        <li class="breadcrumb-item">
                            <a class="" href={'/' + splitUrl.slice(0, i + 1).join('/')}>
                                {slug.replaceAll('_', ' ').replace(/(^|\s)\S/g, (match) => match.toUpperCase())}
                            </a>
                        </li>
                    ))
                }
                <li class="breadcrumb-item active" aria-current="page"></li>
            </ol>
        </nav>
    </div>
    <Content />
    <FooterPrevNext slot="pre-footer" md_github_url={md_github_url} prev_page={prev_page} next_page={next_page} />
</MarkdownTocLayout>
<style lang="scss">
    @import '@styles/_variables.scss';
    nav {
        --bs-breadcrumb-divider: '\f054';
    }
    .breadcrumb-item,
    .breadcrumb-item a,
    .breadcrumb-item::before {
        color: $gray-200 !important;
    }
    .breadcrumb-item::before {
        font-family: 'Font Awesome 6 Pro';
        font-size: 0.8rem;
        margin-top: 0.2rem;
    }
</style>
