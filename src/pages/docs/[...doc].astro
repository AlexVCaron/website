---
import MarkdownTocLayout from '@layouts/MarkdownTocLayout.astro';
import FooterPrevNext from '@components/footer/FooterPrevNext.astro';
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import type { SidebarEntry } from '@utils/types';
import { findCurrentGroup, createLinkOrGroup } from '@utils/functions';
import { Icon } from 'astro-icon/components';
import TutorialProgessIndicator from '@components/sidebar/TutorialProgessIndicator.svelte';

export async function getStaticPaths() {
    const docs = await getCollection('docs');
    return docs.map((doc) => ({
        params: {
            doc: doc.slug,
        },
        props: {
            doc: doc,
        },
    }));
}
const title = Astro.props.doc.data.title;
const subtitle = Astro.props.doc.data.subtitle;
const { headings, Content, remarkPluginFrontmatter } = await Astro.props.doc.render();

let prev_page: { title: string; slug: string } | null = null;
let next_page: { title: string; slug: string } | null = null;

const docs = await getCollection('docs');
let sections: SidebarEntry[] = [
    { type: 'group', label: 'Tutorials', href: '/docs/tutorials', entries: [], collapsed: true },
    { type: 'group', label: 'Usage', href: '/docs/usage', entries: [], collapsed: true },
    { type: 'group', label: 'Checklists', href: '/docs/checklists', entries: [], collapsed: true },
    { type: 'group', label: 'Guidelines', href: '/docs/guidelines', entries: [], collapsed: true },
];

const addEntriesToSection = (sections, docs: CollectionEntry<'docs'>[]) => {
    docs.sort((a, b) => a.slug.localeCompare(b.slug));

    docs.forEach((doc) => {
        const parts = doc.slug.split('/');
        let currentLevel = sections;

        parts.forEach((part, i) => {
            part = part.replaceAll('_', ' ').replace(/(^)\S/g, (match) => match.toUpperCase());
            const existingEntry = currentLevel.find((entry) => entry.label === part);
            if (parts[parts.length - 1].endsWith('bioconda')) {
                debugger;
            }
            if (existingEntry) {
                if (existingEntry.type === 'group') {
                    // workaround for index files in nested events, where another element could already have created the group
                    if (/index\.(md|mdx)$/.test(doc.id) && i === parts.length - 1) {
                        existingEntry.href = '/docs/' + doc.slug;
                        existingEntry.isCurrent = Astro.url.pathname === '/docs/' + doc.slug;
                        existingEntry.collapsed = Astro.url.pathname === '/docs/' + doc.slug;
                    }
                    currentLevel = existingEntry.entries;
                } else {
                    existingEntry.type = 'group';
                    existingEntry.collapsed = true;
                    existingEntry.entries = [];

                    if (/index\.(md|mdx)$/.test(doc.id) && i === parts.length - 1) {
                        existingEntry.href = '/docs/' + doc.slug;
                        existingEntry.isCurrent = Astro.url.pathname === '/docs/' + doc.slug;
                        existingEntry.collapsed = Astro.url.pathname === '/docs/' + doc.slug;
                    }
                    currentLevel = existingEntry.entries;
                }
            } else {
                const newEntry = createLinkOrGroup(
                    part,
                    '/docs/' + doc.slug,
                    i === parts.length - 1,
                    Astro.url.pathname,
                    doc.data.weight,
                );
                currentLevel.push(newEntry);

                if (newEntry.type === 'group' && newEntry.entries) {
                    currentLevel = newEntry.entries;
                }
            }
        });
    });
};
addEntriesToSection(sections, docs);
// sort all entries by weight if available recursively
const sortEntries = (entries: SidebarEntry[]) => {
    entries.sort((a, b) => {
        if (a.weight && !b.weight) {
            return -1;
        } else if (!a.weight && b.weight) {
            return 1;
        } else if (a.weight && b.weight && a.weight !== b.weight) {
            if (a.weight < b.weight) {
                return -1;
            } else if (a.weight > b.weight) {
                return 1;
            }
        } else {
            return a.label.localeCompare(b.label);
        }
    });
    entries.forEach((entry) => {
        if (entry.type === 'group' && entry.entries) {
            sortEntries(entry.entries);
        }
    });
};

sections.forEach((section) => {
    sortEntries(section.entries);
});

// go through all sections and section entries and section entries entries, etc, to find a group containing an elemnt with isCurrent and return all entries

const currentGroup = findCurrentGroup(sections);
let currentGroupIndex = -1;
if (currentGroup.length > 0) {
    currentGroupIndex = currentGroup.findIndex((entry) => entry.isCurrent);
    if (currentGroupIndex === -1) {
        console.error('Could not find current page ' + Astro.url.pathname + ' in docs collection');
    }
    if (currentGroup[currentGroupIndex - 1] && currentGroup[currentGroupIndex - 1].href) {
        prev_page = {
            title: currentGroup[currentGroupIndex - 1].label,
            slug: currentGroup[currentGroupIndex - 1].href,
        };
    }
    if (currentGroup[currentGroupIndex + 1] && currentGroup[currentGroupIndex + 1].href) {
        next_page = {
            title: currentGroup[currentGroupIndex + 1].label,
            slug: currentGroup[currentGroupIndex + 1].href,
        };
    }
}

const docType = Astro.props.doc.data.type;

const md_github_url = 'https://github.com/nf-core/website/blob/main/src/content/docs/' + Astro.props.doc.id;
// remove leading and trailing slash
const splitUrl = `${Astro.url.pathname}/`.replace(/^\/|\/$/g, '').split('/');
// check if markdown file starts with a heading (markdown or html)
const firstHeading = Astro.props.doc.body.trim().match(/^(#|<h1)/);
---

<MarkdownTocLayout
    title={title}
    subtitle={subtitle}
    meta_title={'Docs: ' + title}
    md_github_url={md_github_url}
    headings={headings}
    leftSidebar={true}
    rightSidebar={true}
    sections={sections}
    viewTransitions={true}
    docSearchTags={[
        { name: 'page_type', content: 'Docs' },
        { name: 'page_rank', content: '8' },
        // { name: 'page_subtype', content: currentDocs === usageDocs ? 'Usage' : 'Contributing' },
    ]}
>
    <div slot="header-top" class="d-none d-md-block">
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                {
                    splitUrl.slice(0, -1).map((slug, i) => (
                        <>
                            <li class="breadcrumb-item">
                                <a class="" href={'/' + splitUrl.slice(0, i + 1).join('/')}>
                                    {slug.replaceAll('_', ' ').replace(/(^|\s)\S/g, (match) => match.toUpperCase())}
                                </a>
                            </li>
                            <Icon name="octicon:chevron-right-16" class={'mt-1'} />
                        </>
                    ))
                }
            </ol>
        </nav>
    </div>
    {!firstHeading && <h1>{title}</h1>}
    <Content />
    {
        docType === 'tutorial' && (
            <div slot="right-sidebar-top">
                {currentGroup &&
                    currentGroupIndex !== -1 &&
                    currentGroup.map((entry, i) => {
                        if (i === currentGroupIndex) {
                            return (
                                <TutorialProgessIndicator
                                    label={i + 1}
                                    title={entry.label}
                                    progress={0}
                                    href={entry.href}
                                    client:idle
                                />
                            );
                        } else if (i < currentGroupIndex) {
                            return (
                                <TutorialProgessIndicator
                                    label={i + 1}
                                    title={entry.label}
                                    progress={100}
                                    href={entry.href}
                                />
                            );
                        } else {
                            return (
                                <TutorialProgessIndicator
                                    label={i + 1}
                                    title={entry.label}
                                    progress={0}
                                    href={entry.href}
                                />
                            );
                        }
                    })}
            </div>
        )
    }
    <FooterPrevNext slot="pre-footer" md_github_url={md_github_url} prev_page={prev_page} next_page={next_page} />
</MarkdownTocLayout>
<style lang="scss">
    @import '@styles/_variables.scss';
    nav {
        --bs-breadcrumb-divider: '\f054';
    }
    .breadcrumb-item,
    .breadcrumb-item a,
    .breadcrumb-item::before {
        color: $gray-200 !important;
    }
    .breadcrumb-item::before {
        font-family: 'Font Awesome 6 Pro';
        font-size: 0.8rem;
        margin-top: 0.2rem;
    }
</style>
