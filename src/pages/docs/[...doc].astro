---
import MarkdownTocLayout from '@layouts/MarkdownTocLayout.astro';
import FooterPrevNext from '@components/footer/FooterPrevNext.astro';
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import type { SidebarEntry } from '@utils/types';
import { createLinkOrGroup } from '@utils/functions';

export async function getStaticPaths() {
    const docs = await getCollection('docs');
    return docs.map((doc) => ({
        params: {
            doc: doc.slug,
        },
        props: {
            doc: doc,
        },
    }));
}
const title = Astro.props.doc.data.title;
const subtitle = Astro.props.doc.data.subtitle;
const { headings, Content, remarkPluginFrontmatter } = await Astro.props.doc.render();

let prev_page: CollectionEntry<'docs'> | null = null;
let next_page: CollectionEntry<'docs'> | null = null;

const docs = await getCollection('docs');
let sections: SidebarEntry[] = [
    { type: 'group', label: 'Tutorials', href: '/docs/tutorials', entries: [], collapsed: true },
    { type: 'group', label: 'Usage', href: '/docs/usage', entries: [], collapsed: true },
    { type: 'group', label: 'Checklists', href: '/docs/checklists', entries: [], collapsed: true },
    { type: 'group', label: 'Guidelines', href: '/docs/guidelines', entries: [], collapsed: true },
];

// sort docs first depth, then by weight, then by title
const sortDocs = (a: CollectionEntry<'docs'>, b: CollectionEntry<'docs'>) => {
    if (a.slug.split('/').length < b.slug.split('/').length) {
        return -1;
    } else if (a.slug.split('/').length > b.slug.split('/').length) {
        return 1;
    } else {
        if (a.data.weight && !b.data.weight) {
            return -1;
        } else if (!a.data.weight && b.data.weight) {
            return 1;
        } else if (a.data.weight && b.data.weight) {
            if (a.data.weight < b.data.weight) {
                return -1;
            } else if (a.data.weight > b.data.weight) {
                return 1;
            }
        } else {
            if (a.data.title < b.data.title) {
                return -1;
            } else if (a.data.title > b.data.title) {
                return 1;
            } else {
                return 0;
            }
        }
    }
};
let usageDocs: CollectionEntry<'docs'>[] = [];
let tutorialDocs: CollectionEntry<'docs'>[] = [];
let checklistDocs: CollectionEntry<'docs'>[] = [];
let guidelineDocs: CollectionEntry<'docs'>[] = [];
docs.map((doc) => {
    if (doc.slug.startsWith('Tutorials/')) {
        tutorialDocs.push(doc);
    }
    if (doc.slug.startsWith('Usage/')) {
        usageDocs.push(doc);
    }
    if (doc.slug.startsWith('Checklists/')) {
        checklistDocs.push(doc);
    }
    if (doc.slug.startsWith('Guidelines/')) {
        guidelineDocs.push(doc);
    }
});
tutorialDocs.sort(sortDocs);
usageDocs.sort(sortDocs);
checklistDocs.sort(sortDocs);
guidelineDocs.sort(sortDocs);

const addEntriesToSection = (sections, docs: CollectionEntry<'docs'>[]) => {
    const createLinkOrGroup = (part, path, isLastPart, weight) => {
        let entry: SidebarEntry = {
            label: part,
            href: '/docs/' + path,
            isCurrent: Astro.url.pathname.replace('.html', '') === '/docs/' + path,
            type: isLastPart ? 'link' : 'group',
        };
        if (isLastPart && weight) {
            entry.weight = weight;
        }

        if (entry.type === 'group') {
            entry.entries = [];
            entry.collapsed = true; // You can set this dynamically as well
        }

        return entry;
    };

    const docSlugs = docs.map((doc) => doc.slug);
    docSlugs.forEach((slug) => {
        const parts = slug.split('/');
        let currentLevel = sections;

        parts.forEach((part, i) => {
            part = part.replaceAll('_', ' ').replace(/(^)\S/g, (match) => match.toUpperCase());
            const existingEntry = currentLevel.find((entry) => entry.label === part);

            if (existingEntry && existingEntry.type === 'group') {
                currentLevel = existingEntry.entries;
            } else {
                const newEntry = createLinkOrGroup(
                    part,
                    slug,
                    i === parts.length - 1,
                    docs.find((doc) => doc.slug === slug)?.data.weight,
                );
                currentLevel.push(newEntry);

                if (newEntry.type === 'group' && newEntry.entries) {
                    currentLevel = newEntry.entries;
                }
            }
        });
    });
};

addEntriesToSection(sections, docs);
// sort all entries by weight if available recursively
const sortEntries = (entries: SidebarEntry[]) => {
    entries.sort((a, b) => {
        if (a.weight && !b.weight) {
            return -1;
        } else if (!a.weight && b.weight) {
            return 1;
        } else if (a.weight && b.weight) {
            if (a.weight < b.weight) {
                return -1;
            } else if (a.weight > b.weight) {
                return 1;
            }
        } else {
            if (a.label < b.label) {
                return -1;
            } else if (a.label > b.label) {
                return 1;
            } else {
                return 0;
            }
        }
    });
    entries.forEach((entry) => {
        if (entry.type === 'group' && entry.entries) {
            sortEntries(entry.entries);
        }
    });
};

sections.forEach((section) => {
    sortEntries(section.entries);
});
// find the index of the current page and use that to get the previous and next page
const url = Astro.url.pathname.replace(/\/$/, '').replace(/\.html$/, '');
const currentDocs = (() => {
    if (url.startsWith('/docs/tutorials')) {
        return tutorialDocs;
    } else if (url.startsWith('/docs/usage')) {
        return usageDocs;
    } else if (url.startsWith('/docs/checklists')) {
        return checklistDocs;
    } else if (url.startsWith('/docs/guidelines')) {
        return guidelineDocs;
    }
})();
// // add entries to sections
// tutorialDocs.forEach((doc) => {
//     // get sections for tutorials
//     let index = sections.findIndex((section) => section.label === 'Tutorials');

//     sections[index].type === 'group' &&
//         sections[index].entries.push({
//             type: 'link',
//             label: doc.data.title,
//             href: '/docs/' + doc.slug,
//             isCurrent: Astro.url.pathname === '/docs/' + doc.slug,
//         });
// });
if (!currentDocs) {
    console.error('Could not find current page ' + Astro.url.pathname + ' in docs collection');
} else {
    const current_page_index = currentDocs.findIndex((page) => '/docs/' + page.slug === url);

    if (current_page_index === -1) {
        console.error('Could not find current page ' + Astro.url.pathname + ' in docs collection');
    } else {
        prev_page = currentDocs[current_page_index - 1];
        prev_page =
            prev_page && prev_page.slug?.split('/').slice(-2)[0] === url.split('/').slice(-2)[0] ? prev_page : null;
        next_page = currentDocs[current_page_index + 1];
        next_page =
            next_page && next_page.slug?.split('/').slice(-2)[0] === url.split('/').slice(-2)[0] ? next_page : null;
    }
}
const md_github_url = 'https://github.com/nf-core/website/blob/main/src/content/docs/' + Astro.props.doc.id;
// remove leading and trailing slash
const splitUrl = `${url}/`.replace(/^\/|\/$/g, '').split('/');
// check if markdown file starts with a heading (markdown or html)
const firstHeading = Astro.props.doc.body.match(/^(#|<h1)/);
---

<MarkdownTocLayout
    title={title}
    subtitle={subtitle}
    meta_title={'Docs: ' + title}
    md_github_url={md_github_url}
    headings={headings}
    leftSidebar={true}
    rightSidebar={true}
    sections={sections}
    viewTransitions={true}
    docSearchTags={[
        { name: 'page_type', content: 'Docs' },
        { name: 'page_rank', content: '8' },
        { name: 'page_subtype', content: currentDocs === usageDocs ? 'Usage' : 'Contributing' },
    ]}
>
    <div slot="header-top" class="d-none d-md-block">
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                {
                    splitUrl.slice(0, -1).map((slug, i) => (
                        <li class="breadcrumb-item">
                            <a class="" href={'/' + splitUrl.slice(0, i + 1).join('/')}>
                                {slug.replaceAll('_', ' ').replace(/(^|\s)\S/g, (match) => match.toUpperCase())}
                            </a>
                        </li>
                    ))
                }
                <li class="breadcrumb-item active" aria-current="page"></li>
            </ol>
        </nav>
    </div>
    {!firstHeading && <h1>{title}</h1>}
    <Content />
    <FooterPrevNext slot="pre-footer" md_github_url={md_github_url} prev_page={prev_page} next_page={next_page} />
</MarkdownTocLayout>
<style lang="scss">
    @import '@styles/_variables.scss';
    nav {
        --bs-breadcrumb-divider: '\f054';
    }
    .breadcrumb-item,
    .breadcrumb-item a,
    .breadcrumb-item::before {
        color: $gray-200 !important;
    }
    .breadcrumb-item::before {
        font-family: 'Font Awesome 6 Pro';
        font-size: 0.8rem;
        margin-top: 0.2rem;
    }
</style>
