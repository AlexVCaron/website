---
import MarkdownTocLayout from '@layouts/MarkdownTocLayout.astro';
import FooterPrevNext from '@components/footer/FooterPrevNext.astro';
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import type { SidebarEntry } from '@utils/types';
import { findCurrentGroup, createLinkOrGroup } from '@utils/functions';
import { Icon } from 'astro-icon/components';
import TutorialProgessIndicator from '@components/sidebar/TutorialProgessIndicator.svelte';

export async function getStaticPaths() {
    const docs = await getCollection('docs');
    return docs.map((doc) => ({
        params: {
            doc: doc.slug,
        },
        props: {
            doc: doc,
        },
    }));
}
const title = Astro.props.doc.data.title;
const subtitle = Astro.props.doc.data.subtitle;
const { headings, Content, remarkPluginFrontmatter } = await Astro.props.doc.render();

let prev_page: { title: string; slug: string } | null = null;
let next_page: { title: string; slug: string } | null = null;

const docs = await getCollection('docs');
let sections: SidebarEntry[] = [
    { type: 'group', label: 'Tutorials', href: '/docs/tutorials', entries: [], collapsed: true },
    { type: 'group', label: 'Usage', href: '/docs/usage', entries: [], collapsed: true },
    { type: 'group', label: 'Checklists', href: '/docs/checklists', entries: [], collapsed: true },
    { type: 'group', label: 'Guidelines', href: '/docs/guidelines', entries: [], collapsed: true },
];

const addEntriesToSection = (sections, docs: CollectionEntry<'docs'>[]) => {
    docs.sort((a, b) => a.slug.localeCompare(b.slug));

    docs.forEach((doc) => {
        const parts = doc.slug.split('/');
        let currentLevel = sections;

        parts.forEach((part, i) => {
            part = part.replaceAll('_', ' ').replace(/(^)\S/g, (match) => match.toUpperCase());
            const existingEntry = currentLevel.find((entry) => entry.label === part);
            if (parts[parts.length - 1].endsWith('bioconda')) {
                debugger;
            }
            if (existingEntry) {
                if (existingEntry.type === 'group') {
                    // workaround for index files in nested events, where another element could already have created the group
                    if (/index\.(md|mdx)$/.test(doc.id) && i === parts.length - 1) {
                        existingEntry.href = '/docs/' + doc.slug;
                        existingEntry.isCurrent = Astro.url.pathname === '/docs/' + doc.slug;
                        existingEntry.collapsed = Astro.url.pathname === '/docs/' + doc.slug;
                    }
                    currentLevel = existingEntry.entries;
                } else {
                    existingEntry.type = 'group';
                    existingEntry.collapsed = true;
                    existingEntry.entries = [];

                    if (/index\.(md|mdx)$/.test(doc.id) && i === parts.length - 1) {
                        existingEntry.href = '/docs/' + doc.slug;
                        existingEntry.isCurrent = Astro.url.pathname === '/docs/' + doc.slug;
                        existingEntry.collapsed = Astro.url.pathname === '/docs/' + doc.slug;
                    }
                    currentLevel = existingEntry.entries;
                }
            } else {
                const newEntry = createLinkOrGroup(
                    part,
                    '/docs/' + doc.slug,
                    i === parts.length - 1,
                    Astro.url.pathname,
                    doc.data.weight,
                );
                currentLevel.push(newEntry);

                if (newEntry.type === 'group' && newEntry.entries) {
                    currentLevel = newEntry.entries;
                }
            }
        });
    });
};
addEntriesToSection(sections, docs);
// sort all entries by weight if available recursively
const sortEntries = (entries: SidebarEntry[]) => {
    entries.sort((a, b) => {
        if (a.weight && !b.weight) {
            return -1;
        } else if (!a.weight && b.weight) {
            return 1;
        } else if (a.weight && b.weight && a.weight !== b.weight) {
            if (a.weight < b.weight) {
                return -1;
            } else if (a.weight > b.weight) {
                return 1;
            }
        } else {
            return a.label.localeCompare(b.label);
        }
    });
    entries.forEach((entry) => {
        if (entry.type === 'group' && entry.entries) {
            sortEntries(entry.entries);
        }
    });
};

sections.forEach((section) => {
    sortEntries(section.entries);
});

// go through all sections and section entries and section entries entries, etc, to find a group containing an elemnt with isCurrent and return all entries

const currentGroup = findCurrentGroup(sections);
const currentElement = currentGroup.find((entry) => entry.isCurrent);

let currentGroupIndex = -1;
if (currentGroup.length > 0) {
    currentGroupIndex = currentGroup.findIndex((entry) => entry.isCurrent);
    if (currentGroupIndex === -1) {
        console.error('Could not find current page ' + Astro.url.pathname + ' in docs collection');
    }
    if (currentElement && currentElement.type === 'group') {
        next_page = {
            title: currentElement.entries[0].label,
            slug: currentElement.entries[0].href,
        };
    } else {
        if (currentGroup[currentGroupIndex - 1] && currentGroup[currentGroupIndex - 1].href) {
            prev_page = {
                title: currentGroup[currentGroupIndex - 1].label,
                slug: currentGroup[currentGroupIndex - 1].href,
            };
        }
        if (currentGroup[currentGroupIndex + 1] && currentGroup[currentGroupIndex + 1].href) {
            next_page = {
                title: currentGroup[currentGroupIndex + 1].label,
                slug: currentGroup[currentGroupIndex + 1].href,
            };
        }
    }
}

// find subsection which contains the currentGroup
const currentSection = sections
    .map((section) => {
        if (section.entries) {
            return section.entries.find((entry) => entry.entries && entry.entries == currentGroup);
        }
    })
    .filter((section) => section)[0];

const docType = Astro.props.doc.data.type;

console.log('currentElement', currentElement);
const md_github_url = 'https://github.com/nf-core/website/blob/main/src/content/docs/' + Astro.props.doc.id;
// remove leading and trailing slash
const splitUrl = `${Astro.url.pathname}/`.replace(/^\/|\/$/g, '').split('/');
// check if markdown file starts with a heading (markdown or html)
const firstHeading = Astro.props.doc.body.trim().match(/^(#|<h1)/);
---

<MarkdownTocLayout
    title={title}
    subtitle={subtitle}
    meta_title={'Docs: ' + title}
    md_github_url={md_github_url}
    headings={headings}
    leftSidebar={true}
    rightSidebar={true}
    sections={sections}
    viewTransitions={true}
    docSearchTags={[
        { name: 'page_type', content: 'Docs' },
        { name: 'page_rank', content: '8' },
        // { name: 'page_subtype', content: currentDocs === usageDocs ? 'Usage' : 'Contributing' },
    ]}
>
    <div slot="header-top" class="d-none d-md-block">
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                {
                    splitUrl.slice(0, -1).map((slug, i) => (
                        <>
                            <li class="breadcrumb-item">
                                <a class="" href={'/' + splitUrl.slice(0, i + 1).join('/')}>
                                    {slug.replaceAll('_', ' ').replace(/(^|\s)\S/g, (match) => match.toUpperCase())}
                                </a>
                            </li>
                            <Icon name="octicon:chevron-right-16" class={'mt-1'} />
                        </>
                    ))
                }
            </ol>
        </nav>
    </div>
    {!firstHeading && <h1>{title}</h1>}
    <Content />
    {
        docType === 'tutorial' && currentElement && currentElement?.type === 'link' && (
            <div slot="right-sidebar-top" class="border border-success rounded p-3 pb-2">
                <p>
                    <strong class="h5 my-2">Tutorial:</strong>
                    <a href={currentSection.href}>{currentSection.label}</a>
                </p>
                <div class="d-flex flex-column">
                    {currentGroup &&
                        currentGroupIndex !== -1 &&
                        currentGroup.map((entry, i) => {
                            if (i === currentGroupIndex) {
                                return (
                                    <TutorialProgessIndicator
                                        label={i + 1}
                                        title={entry.label}
                                        progress={0}
                                        href={entry.href}
                                        client:idle
                                    />
                                );
                            } else if (i < currentGroupIndex) {
                                return (
                                    <TutorialProgessIndicator
                                        label={i + 1}
                                        title={entry.label}
                                        progress={100}
                                        href={entry.href}
                                    />
                                );
                            } else {
                                return (
                                    <TutorialProgessIndicator
                                        label={i + 1}
                                        title={entry.label}
                                        progress={0}
                                        href={entry.href}
                                    />
                                );
                            }
                        })}
                </div>
            </div>
        )
    }{
        docType === 'tutorial' && currentElement?.type === 'group' && (
            <div slot="right-sidebar-top" class="border border-success rounded p-3 pb-2">
                <span>
                    <strong class="h5 my-2">Tutorial:</strong>
                    <a href={currentElement.href}>{currentElement.label}</a>
                </span>
                <div class="d-flex flex-column">
                    {currentElement?.entries.map((entry, i) => (
                        <TutorialProgessIndicator label={i + 1} title={entry.label} progress={0} href={entry.href} />
                    ))}
                </div>
            </div>
        )
    }
    <FooterPrevNext slot="pre-footer" md_github_url={md_github_url} prev_page={prev_page} next_page={next_page} />
</MarkdownTocLayout>
<style lang="scss">
    @import '@styles/_variables.scss';
    nav {
        --bs-breadcrumb-divider: '\f054';
    }
    .breadcrumb-item,
    .breadcrumb-item a,
    .breadcrumb-item::before {
        color: $gray-200 !important;
    }
    .breadcrumb-item::before {
        font-family: 'Font Awesome 6 Pro';
        font-size: 0.8rem;
        margin-top: 0.2rem;
    }
</style>
