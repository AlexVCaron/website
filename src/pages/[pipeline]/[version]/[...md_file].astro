---
import { Markdown } from '@astropub/md';
import MarkdownWrapper from '@components/markdown/MarkdownWrapper.svelte';
import SidebarToc from '@components/sidebar/SidebarToc.svelte';
import SidebarNav from '@components/sidebar/SidebarNav.astro';
import PipelinePageLayout from '@layouts/PipelinePageLayout.astro';
import pipelines_json from '@public/pipelines.json';
import cache from 'bin/cache.js';
import { getGitHubFile } from '@components/octokit';

import ExpandDetailsButton from '@components/sidebar/ExpandDetailsButton.svelte';

export function getStaticPaths() {
    let paths: { params: { pipeline: string; version: string; md_file: string }; props: { versions; md_files } }[] = [];
    pipelines_json.remote_workflows.forEach((pipeline) => {
        pipeline.releases.forEach((release) => {
            const md_files = release.doc_files.map((file) => file.replace('docs/', '').replace('.md', ''));
            md_files.forEach((md_file) => {
                paths.push({
                    params: {
                        pipeline: pipeline.name,
                        version: release.tag_name,
                        md_file: md_file,
                    },
                    props: {
                        versions: pipeline.releases.map((release) => release.tag_name),
                        md_files: md_files,
                    },
                });
            });
        });
    });
    return paths;
}
const { pipeline, version, md_file } = Astro.params;
const { versions, md_files } = Astro.props;
let headings: {
    depth: number;
    text: string;
    slug: string;
}[] = [];

const description = pipelines_json.remote_workflows.filter((p) => p.name === pipeline).description;
const left_sidebar =
    md_file.split('/').length > 1 || md_files.filter((file) => file.split('/')[0] === md_file.split('/')[0]).length > 1;
let sections = {};
let siblings = [];
if (left_sidebar) {
    siblings = md_files.filter((file) => file.split('/')[0] === md_file.split('/')[0]);
    sections = { section_name: siblings[0], children: siblings.slice(1) };
    //make title case
    sections.section_name = sections.section_name
        .split('/')[0]
        .replace(/-/g, ' ')
        .replace(/\w\S*/g, (w) => w.replace(/^\w/, (c) => c.toUpperCase()));
    sections.children = sections.children.map((child) => {
        return {
            title: child
                .split('/')[1]
                .split('/')[0]
                .replace(/-/g, ' ')
                .replace(/\w\S*/g, (w) => w.replace(/^\w/, (c) => c.toUpperCase())),
            slug: child,
        };
    });
}

const cache_key = `${pipeline}/${version}/docs/${md_file}.md`;

const md_content = await cache
    .get(cache_key)
    .catch((error) => {
        console.log(error);
        return;
    })
    .then(async (response) => {
        let content = response;
        if (content === undefined) {
            console.log(`Cache miss for ${cache_key}`);
            content = await getGitHubFile(pipeline, `/docs/${md_file}.md`, version);
        }

        const text_content = content.replace(/```(.*?)```/gs, '');
        // get headings and their depth for table of contents
        headings = text_content.match(/^(#{1,6})\s(.*)$/gm).map((heading) => {
            const depth = heading.match(/^(#{1,6})/)[0].length;
            let text = heading.match(/^(#{1,6})\s(.*)$/)[2];
            // check if exactly two backticks are used to wrap text
            if (text.match(/`(.+?)`/g)) {
                text = text.replace(/`(.+?)`/g, '<code>$1</code>');
                const slug = text
                    .replace(/<code>(.*?)<\/code>/g, '$1')
                    .toLowerCase()
                    .replace(/ /g, '-')
                    .replace(/[^\w-]+/g, '');
                return { depth, text, slug };
            } else {
                const slug = text
                    .toLowerCase()
                    .replace(/ /g, '-')
                    .replace(/[^\w-]+/g, '');
                return { depth, text, slug };
            }
        });
        return content;
    });

const max_heading_depth = 2;

// filter out headings that are higher than max_heading_depth
headings = headings.filter((h) => h.depth <= max_heading_depth);
---

<PipelinePageLayout
    pipeline={pipeline}
    subtitle={description}
    headings={headings}
    version={version}
    versions={versions}
    tabItems={md_files}
    md_github_url={`https://github.com/nf-core/${pipeline}/blob/${version}/docs/${md_file}.md`}
>
    <div class="row">
        {
            left_sidebar && (
                <div class="col-12 col-md-2 sticky-top-under d-none d-md-inline sidebar-left">
                    <SidebarNav items={[sections]} />
                </div>
            )
        }
        <div class:list={['col-12 pt-3', { 'col-md-9': !left_sidebar, 'col-md-8': left_sidebar }]}>
            <MarkdownWrapper client:load headings={headings}>
                <Markdown of={md_content} />
            </MarkdownWrapper>
        </div>
        <div class:list={['col-12 toc', { 'col-md-3': !left_sidebar, 'col-md-2': left_sidebar }]}>
            <SidebarToc headings={headings} client:idle><ExpandDetailsButton client:idle /></SidebarToc>
        </div>
    </div>
</PipelinePageLayout>pip
