---
import SchemaListing from '@components/SchemaListing.svelte';
import SchemaListingToc from '@components/SchemaListingToc.svelte';
import SidebarToc from '@components/SidebarToc.svelte';
import octokit from '@components/octokit';
import PipelinePageLayout from '@layouts/PipelinePageLayout.astro';
import pipelines_json from '@public/pipelines.json';

export function getStaticPaths() {
    const paths = pipelines_json.remote_workflows.map((pipeline) => {
        const releases = [...pipeline.releases, { tag_name: 'dev' }];
        const params = releases.map((release) => {
            return {
                params: { pipeline: pipeline.name, version: release.tag_name },
            };
        });
        return params;
    });
    return paths;
}
const { pipeline, version } = Astro.params;
const currentPipeline = pipelines_json.remote_workflows.filter((p) => p.name === pipeline)[0];
const description = currentPipeline.description ? currentPipeline.description : '';
const schema = await octokit
    .request('GET /repos/{owner}/{repo}/contents/{path}{?ref}', {
        owner: 'nf-core',
        repo: pipeline,
        path: `nextflow_schema.json`,
        ref: version,
    }) // parse file if found
    .catch((error) => {
        if (error.status === 404) {
            console.log('Schema not found for ' + pipeline + ' ' + version);
            return { status: 404 };
        } else {
            throw error;
        }
    })
    .then((response) => {
        if (response.status === 200) {
            return JSON.parse(Buffer.from(response.data.content, 'base64').toString('utf-8'));
        } else {
            return { definitions: {} };
        }
    });

let headings = [];
if (schema.definitions && Object.keys(schema.definitions).length > 0) {
    headings = Object.entries(schema.definitions).map(([key, value]) => {
        return {
            slug: key.replaceAll('_', '-'),
            text: value.title,
            depth: 1,
            fa_icon: value.fa_icon,
        };
    });
} else if (schema.properties && Object.keys(schema.properties).length > 0) {
    schema.definitions = schema.properties; // catching the case where there is no definitions but only properties
}

const activeTabItem = 'Parameters';
let versions = currentPipeline.releases
    .map((r) => {
        return r.tag_name;
    })
    .flat();
versions.push('dev');
const baseUrl = '/' + pipeline + '/' + version;
let tabItems = [
    { label: 'Introduction', href: baseUrl, active: false, icon: 'fa-solid fa-sign-in' },
    { label: 'Parameters', href: baseUrl + '/parameters', active: false },
    { label: 'Usage', href: baseUrl + '/usage', active: false },
    { label: 'Output', href: baseUrl + '/output', active: false },
];

tabItems = tabItems.map((item) => {
    if (item.label === activeTabItem) {
        item.active = true;
    }
    return item;
});
---

<PipelinePageLayout
    pipeline={pipeline}
    subtitle={description}
    headings={headings}
    version={version}
    versions={versions}
    tabItems={tabItems}
>
    <div class="row">
        <div class="col-12 col-md-10">
            {
                Object.keys(schema.definitions).length === 0 && (
                    <div class="alert alert-warning mt-3 " role="alert">
                        <h4 class="text-warning">No nextflow_schema.json file found!</h4>
                        <p>
                            It seems like there is no nextflow_schema.json file with parameters defined for this version
                            of the pipeline. Try a newer version.
                        </p>
                    </div>
                )
            }

            <SchemaListing {schema} client:load />
        </div>
        <div class="col-12 col-md-2 toc order-first order-md-last pe-0">
            <SchemaListingToc headings={headings} client:idle />
        </div>
    </div>
</PipelinePageLayout>

<style lang="scss"></style>
