---
import MarkdownWrapper from '@components/markdown/MarkdownWrapper.svelte';
import SidebarToc from '@components/sidebar/SidebarToc.svelte';
import SidebarNav from '@components/sidebar/SidebarNav.astro';
import PipelinePageLayout from '@layouts/PipelinePageLayout.astro';
import pipelines_json from '@public/pipelines.json';
import { getEntry } from 'astro:content';
import type { SidebarEntry } from '@utils/types';

import ExpandDetailsButton from '@components/sidebar/ExpandDetailsButton.svelte';

export function getStaticPaths() {
    let paths: {
        params: { pipeline: string; version: string; md_file: string };
        props: { versions: string[]; md_files: string[]; description: string };
    }[] = [];
    pipelines_json.remote_workflows.forEach((pipeline) => {
        const releases = pipeline.releases;
        const extended_releases = [...releases, { tag_name: 'latest', doc_files: releases[0].doc_files }];
        extended_releases.forEach((release) => {
            const md_files = release.doc_files.map((file) => {
                return { slug: file.replace('docs/', '').replace('.mdx', '').replace('.md', '') };
            });
            md_files.forEach((md_file) => {
                paths.push({
                    params: {
                        pipeline: pipeline.name,
                        version: release.tag_name,
                        md_file: md_file.slug,
                    },
                    props: {
                        versions: releases.map((release) => release.tag_name),
                        md_files: md_files,
                        description: pipeline.description,
                    },
                });
            });
        });
    });
    return paths;
}
let { pipeline, version, md_file } = Astro.params;
const { versions, md_files, description } = Astro.props;

console.log('md_files', md_files);
const section = md_file.split('/')[0];
// check if there are multiple files in the section
let leftSidebar = md_files.filter((file) => file.slug.split('/')[0] === section).length > 1;

let sections: SidebarEntry[] = [];

// add trailing slash to url if missing
let url = Astro.url.pathname.endsWith('/') ? Astro.url.pathname : Astro.url.pathname + '/';
url = url.replace(/\.html\/$/, '/');

// drop everything after docs/
const baseURL = url.split('/').slice(0, 4).join('/') + '/';
console.log('baseURL', baseURL);
if (leftSidebar) {
    const addEntriesToSection = (sections, md_files) => {
        const createLinkOrGroup = (part, path, isLastPart) => {
            let entry: SidebarEntry = {
                label: part,
                href: baseURL + path,
                isCurrent: Astro.url.pathname === baseURL + path,
                type: isLastPart ? 'link' : 'group',
            };

            if (entry.type === 'group') {
                entry.entries = [];
                entry.collapsed = true; // You can set this dynamically as well
            }

            return entry;
        };

        const docSlugs = md_files.map((doc) => doc.slug);
        docSlugs.forEach((slug) => {
            const parts = slug.split('/');
            let currentLevel = sections;

            parts.forEach((part, i) => {
                part = part.replaceAll('_', ' ').replace(/(^)\S/g, (match) => match.toUpperCase());
                const existingEntry = currentLevel.find((entry) => entry.label === part);

                if (existingEntry) {
                    if (existingEntry.type === 'group') {
                        currentLevel = existingEntry.entries;
                    } else {
                        existingEntry.type = 'group';
                        existingEntry.collapsed = Astro.url.pathname !== existingEntry.href;
                        existingEntry.entries = [];
                        currentLevel = existingEntry.entries;
                    }
                } else {
                    const newEntry = createLinkOrGroup(part, slug, i === parts.length - 1);
                    currentLevel.push(newEntry);

                    if (newEntry.type === 'group' && newEntry.entries) {
                        currentLevel = newEntry.entries;
                    }
                }
            });
        });
    };

    // const siblings: SidebarEntry[] = md_files
    //     .filter((file) => file.split('/')[0] === section && section !== file)
    //     .map((child) => {
    //         const prefix = md_file !== section ? section + '/' : '';
    //         const title = child
    //             .replace(section + '/', '')
    //             .replace(prefix, '')
    //             .replace(/-/g, ' ')
    //             .replace(/\w\S*/g, (w) => w.replace(/^\w/, (c) => c.toUpperCase()));
    //         const slug = baseURL + child.replace(prefix, '') + '/';
    //         return { type: 'link', label: title, href: slug, isCurrent: md_file === child };
    //     });

    addEntriesToSection(sections, md_files);
}
console.log('sections', sections[1]);
const version_tag_name = version === 'latest' ? versions[0] : version;
const cache_key = `${pipeline}/${version_tag_name?.replaceAll('.', '')}/docs/${md_file?.toLowerCase()}`;

const entry = await getEntry('pipelines', cache_key);
let { Content, headings } = await entry.render();
const max_heading_depth = 2;

// filter out headings that are higher than max_heading_depth
headings = headings.filter((h) => h.depth <= max_heading_depth);
---

<PipelinePageLayout
    pipeline={pipeline}
    meta_title={pipeline +
        ': ' +
        section.replace(/-/g, ' ').replace(/\w\S*/g, (w) => w.replace(/^\w/, (c) => c.toUpperCase()))}
    subtitle={description}
    headings={headings}
    version={version}
    versions={versions}
    tabItems={md_files.map((file) => file.slug)}
    md_github_url={`https://github.com/nf-core/${pipeline}/blob/${version}/docs/${md_file}.md`}
    sections={sections}
    docSearchTags={[
        { name: 'page_rank', content: '5' },
        { name: 'page_subtype', content: 'docs' },
    ]}
>
    <div class="row">
        {
            leftSidebar && (
                <div class="col-12 col-md-2 sticky-top-under d-none d-md-inline sidebar-left pt-3">
                    <SidebarNav items={sections} />
                </div>
            )
        }
        <div class:list={['col-12 pt-3 markdown-content', { 'col-md-9': !leftSidebar, 'col-md-8': leftSidebar }]}>
            <MarkdownWrapper client:load headings={headings}>
                <Content />
            </MarkdownWrapper>
        </div>
        <div class:list={['col-12 toc', { 'col-md-3': !leftSidebar, 'col-md-2': leftSidebar }]}>
            <SidebarToc headings={headings} client:idle><ExpandDetailsButton client:idle /></SidebarToc>
        </div>
    </div>
</PipelinePageLayout>
