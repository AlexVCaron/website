---
import PipelinePageLayout from '@layouts/PipelinePageLayout.astro';
import pipelines_json from '@public/pipelines.json';
import { S3Client, ListObjectsV2Command } from '@aws-sdk/client-s3';
import AWSLinkPreview from '@components/pipeline/AWSLinkPreview.svelte';

// import AWSBrowser from '@components/pipeline/AWSBrowser.svelte';

let { pipeline, version, path } = Astro.params;
const meta = pipelines_json.remote_workflows.find((p) => p.name === pipeline);
const versions = meta.releases.map((release) => release.tag_name);
const md_files = meta.releases.reduce((result, release) => {
    if (release.tag_name === version) {
        result = release.doc_files.map((file) => file.replace('docs/', '').replace('.md', ''));
    }
    return result;
}, []);

const releaseSHA = meta.releases.find((release) => release.tag_name === version)?.sha;
const bucketName = 'nf-core-awsmegatests';
const prefix = `${pipeline}/results-${releaseSHA}/`;
const baseURL = `/${pipeline}/${version}/`;
if (!path) {
    return Astro.redirect(baseURL + 'results/' + prefix);
}

path = path?.endsWith('/') ? path : path + '/';

const pathParts = path.split('/');

const description = meta?.description;
const depth = path.endsWith('/') ? pathParts.length - 1 : pathParts.length;
let client = new S3Client({
    region: 'eu-west-1',
    signer: { sign: async (request) => request },
});

let response;
const bucketContents: { Key: string; LastModified: Date; ETag: string; Size: number; StorageClass: string }[] = [];
let isTruncated = true;
while (isTruncated) {
    response = await client.send(
        new ListObjectsV2Command({
            Bucket: bucketName,
            ContinuationToken: response?.NextContinuationToken,
            Prefix: prefix,
        })
    );
    if (response.KeyCount === 0) {
        break;
    }
    if (response.Contents) {
        bucketContents.push(...response.Contents);

        isTruncated = response.IsTruncated;
    }
}
let directories: { name: string | undefined; path: string; depth: number; size: number; lastModified: Date }[] = [];
let files: { name: string | undefined; path: string; depth: number; size: number; lastModified: Date }[] = [];
if (!isTruncated) {
    directories = bucketContents
        .filter((item) => item.Key.endsWith('/'))
        .map((item) => {
            return {
                name: item.Key.replace(prefix, '').split('/').slice(-2).join('/'),
                path: item.Key,
                depth: item.Key.replace(prefix, '').split('/').length,
                size: item.Size,
                lastModified: item.LastModified,
            };
        })
        .sort((a, b) => a.depth - b.depth);

    // check if element has object of depth 2 and if it does not, create and add the parent object
    const depth2 = directories.filter((item) => item.depth === 2);
    if (depth2.length === 0) {
        // create parent objects based on the parent directory of directories
        const parents = directories
            .filter((item) => item.depth === 3)
            .map((item) => {
                const parent = item.path.replace(prefix, '').split('/').slice(0, -2).join('/');

                return {
                    name: parent,
                    path: prefix + parent,
                    depth: parent.split('/').length + 1,
                };
            });
        // remove duplicated entries in parents
        const uniqueParents = [...new Map(parents.map((item) => [item.name, item])).values()];
        // add parents to directories
        directories = uniqueParents.concat(directories);
    }

    files = bucketContents
        .filter((item) => !item.Key.endsWith('/'))
        .map((item) => {
            return {
                name: item.Key.replace(path + '/', '')
                    .split('/')
                    .pop(),
                path: item.Key,
                depth: item.Key.replace(prefix, '').split('/').length,
                size: item.Size,
                lastModified: item.LastModified,
            };
        })
        .sort((a, b) => a.depth - b.depth);
}

export const prerender = false;
---

<PipelinePageLayout
    pipeline={pipeline}
    subtitle={description}
    version={version}
    versions={versions}
    tabItems={md_files}
>
    <div class="mt-3">
        {
            bucketContents.length === 0 && (
                <div class="alert alert-warning mt-3 " role="alert">
                    <h4 class="text-warning">No AWS results found!</h4>
                    <p>
                        It seems like there is not yet any AWS results for this version of {pipeline}. Please check
                        newer releases of this pipeline.
                    </p>
                </div>
            )
        }
        {
            bucketContents.length > 0 && (
                <div>
                    <nav aria-label="breadcrumb">
                        <ol class="breadcrumb">
                            <li class="breadcrumb-item">
                                <span>
                                    <i class="fa-brands fa-aws me-2" />
                                    {bucketName}
                                </span>
                            </li>
                            <li class="breadcrumb-item">
                                <span>{pipeline}</span>
                            </li>
                            {path &&
                                pathParts.slice(1, -2).map((item, i) => (
                                    <li class="breadcrumb-item">
                                        <a href={baseURL + 'results/' + pathParts.slice(0, i + 2).join('/')}>{item}</a>
                                    </li>
                                ))}
                            <li class="breadcrumb-item active">
                                <a href={pathParts.slice(0, -1).pop()}>{pathParts.slice(0, -1).pop()}</a>
                            </li>
                        </ol>
                    </nav>
                    <table class="table table-hover table-responsive">
                        <thead>
                            <tr>
                                <th scope="col">Name</th>
                                <th scope="col">Last Modified</th>
                                <th scope="col">Size</th>
                            </tr>
                        </thead>
                        <tbody>
                            {depth > 2 && (
                                <tr>
                                    <td>
                                        <a
                                            href={baseURL + 'results/' + pathParts.slice(0, -2).join('/')}
                                            class="text-decoration-none"
                                        >
                                            <i class="fa-regular fa-folder-open me-2" />
                                            ..
                                        </a>
                                    </td>
                                    <td />
                                    <td />
                                </tr>
                            )}
                            {directories &&
                                directories
                                    .filter((item) => item.depth === depth)
                                    .filter((item) => item.path.includes(path))
                                    .map((item) => (
                                        <tr class="position-relative">
                                            <td>
                                                <a
                                                    href={baseURL + 'results/' + path + item.name}
                                                    class="text-decoration-none"
                                                >
                                                    <i class="fa-regular fa-folder me-2 stretched-link" />
                                                    {item.name}
                                                </a>
                                            </td>
                                            <td />
                                            <td />
                                        </tr>
                                    ))}
                            {files &&
                                files
                                    .filter((item) => item.depth === depth - 1)
                                    .filter((item) => item.path.includes(path))
                                    .filter((item) => item.name === 'GM12878_REP1_1_fastqc.html')
                                    .map((item) => (
                                        <AWSLinkPreview item={item} client:load>
                                            {' '}
                                        </AWSLinkPreview>
                                    ))}
                        </tbody>
                    </table>
                    <div id="aws-preview d-none" />
                </div>
            )
        }
    </div>
</PipelinePageLayout>
