---
import octokit, { getGitHubFile } from '@components/octokit';
import SchemaListing from '@components/schema/SchemaListing.svelte';
import SchemaListingToc from '@components/schema/SchemaListingToc.svelte';
import PipelinePageLayout from '@layouts/PipelinePageLayout.astro';
import pipelines_json from '@public/pipelines.json';

const { pipeline } = Astro.params;
const version = 'dev';
let headings: {
    slug: string;
    text: string;
    depth: number;
    fa_icon?: string;
}[] = [];
// check if pipeline and version is in pipelines_json
const meta = pipelines_json.remote_workflows.find(
    (wf) => wf.name === pipeline && wf.releases.flatMap((r) => r.tag_name).includes('dev')
);
if (!meta || !pipeline) {
    return Astro.redirect('/404');
}
const description = meta.description;
const baseUrl = '/' + pipeline + '/' + version;

const versions = meta.releases.map((r) => r.tag_name);
let doc_files = await octokit.rest.repos
    .getContent({
        owner: 'nf-core',
        repo: pipeline,
        path: 'docs',
        ref: 'dev',
    })
    .then((response) => {
        return response.data
            .filter((file: { name: string }) => {
                return file.name.includes('.md') && !file.name.includes('README');
            })
            .map((file: { path: string }) => {
                return file.path.replace('docs/', '').replace('.md', '');
            });
    });
let tabItems = doc_files.map((file: string) => {
    return {
        label: file.replace(/-/g, ' ').replace(/\w\S*/g, (txt: string) => {
            return txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase();
        }),
        href: baseUrl + '/' + file,
        active: false,
    };
});

let schema_raw = await getGitHubFile(pipeline, 'nextflow_schema.json', 'dev');
let schema: { definitions: []; properties: [] };
if (schema_raw === undefined) {
    schema = {
        definitions: [],
        properties: [],
    };
} else {
    schema = JSON.parse(schema_raw);
}
if (schema.definitions && Object.keys(schema.definitions).length > 0) {
    headings = Object.entries(schema.definitions).map(([key, value]) => {
        return {
            slug: key.replaceAll('_', '-'),
            text: value.title,
            depth: 1,
            fa_icon: value.fa_icon,
        };
    });
} else if (schema.properties && Object.keys(schema.properties).length > 0) {
    schema.definitions = schema.properties; // catching the case where there is no definitions but only properties
}

export const prerender = false;
---

<PipelinePageLayout
    pipeline={pipeline}
    subtitle={description}
    headings={headings}
    version={version}
    versions={versions}
    tabItems={tabItems}
>
    <div class="row">
        <div class="col-12 col-md-10">
            <SchemaListing {schema} client:load />
        </div>
        <div class="col-12 col-md-2 toc order-first order-md-last pe-0">
            <SchemaListingToc headings={headings} client:idle />
        </div>
    </div>
</PipelinePageLayout>

<style lang="scss"></style>
